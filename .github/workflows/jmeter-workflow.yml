# ==============================================
# JMeter Test Workflow (Fully Annotated - Every Line)
# Features:
#   - Parallel matrix runs for load tests
#   - Individual and optional aggregated JTL/HTML reports
#   - Dynamic run-name and purpose logging
#   - Cleanup old artifacts and workflow runs
# ==============================================

# Workflow name in GitHub UI
name: JMeter Consumer Workflow

# Dynamic run-name shown in GitHub Actions UI
# Uses user-provided run_id if available, otherwise generates formatted descriptive name
run-name: >
  JMeter Workflow: ${{ github.event.inputs.run_id != '' && github.event.inputs.run_id
      || format('JMeter Run - Env: {0} - Type: {1} - VMs: {2}',
                github.event.inputs.environment,
                github.event.inputs.test_type,
                github.event.inputs.vm_count) }}

# Trigger workflow manually with inputs
on:
  workflow_dispatch:
    inputs:
      # Action to perform: run tests or cleanup old runs
      action:
        description: "Choose action (run-tests or cleanup)"
        required: true
        default: run-tests
        type: choice
        options: [run-tests, cleanup]

      # Optional run ID or purpose, used for naming and logging
      run_id:
        description: "Optional Run ID or Purpose (leave blank for auto)"
        required: false
        default: ""

      # Environment for JMeter tests
      environment:
        description: "Environment for JMeter tests"
        required: true
        default: dev
        type: choice
        options: [dev, staging, prod]

      # Type of JMeter test (load/stress/endurance)
      test_type:
        description: "Type of test to run"
        required: true
        default: load
        type: choice
        options: [load, stress, endurance]

      # Scripts to run, comma-separated
      scripts:
        description: "Comma-separated JMX scripts (default: all)"
        required: false
        default: "create-consumer,get-consumer,get-product,post-product,home-page"

      # Number of parallel VM instances
      vm_count:
        description: "Number of VM instances (matrix size)"
        required: true
        default: 1

      # Retention period for artifacts and cleanup
      retention_days:
        description: "Retention period (days) for artifacts & cleanup"
        required: true
        default: "7"

      # Include extra folders (JMX, data, config) in artifacts
      include_extra:
        description: "Include extra folders (Y/N)"
        required: false
        default: "N"

      # Aggregate all JTL files into a single file and generate merged report
      aggregate:
        description: "Aggregate results into single JTL/HTML (Y/N)"
        required: false
        default: "Y"

# Permissions needed for workflow
permissions:
  contents: write   # Needed to upload artifacts and delete workflow runs
  actions: write    # Needed to delete old workflow runs

# ==============================
# Prepare job to generate run ID and VM matrix
# ==============================
jobs:
  prepare:
    runs-on: ubuntu-latest  # Use latest Ubuntu runner
    outputs:
      RUN_ID: ${{ steps.setid.outputs.RUN_ID }}  # Output run ID for downstream jobs
      MATRIX_INSTANCES: ${{ steps.setmatrix.outputs.matrix }}  # Output JSON array for matrix
    steps:
      # Step: Generate run ID
      - name: Generate runID
        id: setid
        run: |
          # If user provides run_id, use it; otherwise, use timestamp
          if [ -z "${{ github.event.inputs.run_id }}" ]; then
            runid=$(date +%Y%m%d-%H%M%S)  # Timestamp format: YYYYMMDD-HHMMSS
          else
            runid="${{ github.event.inputs.run_id }}"  # Use user-provided run_id
          fi
          # Export run ID for other jobs
          echo "RUN_ID=$runid" >> $GITHUB_OUTPUT

      # Step: Generate matrix for VM instances
      - name: Generate VM matrix
        id: setmatrix
        run: |
          COUNT=${{ github.event.inputs.vm_count }}  # Read VM count input
          if [ -z "$COUNT" ]; then COUNT=1; fi  # Default to 1
          MATRIX=$(seq -s, 1 $COUNT | sed 's/,/","/g')  # Comma-separated list
          MATRIX="[\"$MATRIX\"]"  # JSON array format
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT  # Export matrix

# ==============================
# Run JMeter tests in parallel using matrix
# ==============================
  run-tests:
    name: Run JMeter (Instance ${{ matrix.instance }})  # Job name includes instance number
    if: ${{ github.event.inputs.action == 'run-tests' }}  # Only run if action is 'run-tests'
    needs: prepare  # Depends on prepare job
    runs-on: ubuntu-latest  # Each instance runs on separate VM
    strategy:
      matrix:
        instance: ${{ fromJSON(needs.prepare.outputs.MATRIX_INSTANCES) }}  # Matrix instances
      fail-fast: false  # Continue other instances even if one fails

    steps:
      # Step: Checkout repository code
      - uses: actions/checkout@v4

      # Step: Setup Java environment
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin  # Use Eclipse Temurin JDK
          java-version: "17"  # Java version

      # Step: Print run summary
      - name: Print Run Summary
        run: |
          # Display workflow run details for logging/debugging
          echo "===================================================="
          echo " GitHub Actions Run Summary "
          echo " Purpose   : ${{ needs.prepare.outputs.RUN_ID }}"
          echo " Env       : ${{ github.event.inputs.environment }}"
          echo " Test Type : ${{ github.event.inputs.test_type }}"
          echo " Scripts   : ${{ github.event.inputs.scripts }}"
          echo " VM Count  : ${{ github.event.inputs.vm_count }}"
          echo " Instance  : ${{ matrix.instance }}"
          echo " Retention : ${{ github.event.inputs.retention_days }} days"
          echo " Run URL   : https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "===================================================="

      # Step: Print system information (optional)
      - name: Print System Info
        run: |
          PRINT_DEBUG="true"  # Set true to display system info
          if [ "$PRINT_DEBUG" = "true" ]; then
            echo "===== Runner System Info ====="
            echo "Public IP:"; curl -s ifconfig.me || true; echo
            echo "Geo Location:"; curl -s ipinfo.io || true; echo
            echo "CPU Info:"; nproc; lscpu | grep "Model name"
            echo "Memory Info:"; free -h
          fi

      # Step: Validate JMX scripts and folder structure
      - name: Validate folder structure and scripts
        run: |
          TEST_TYPE="${{ github.event.inputs.test_type }}"  # Test type
          SCRIPTS="${{ github.event.inputs.scripts }}"      # Scripts list
          IFS=',' read -ra SCRIPT_ARR <<< "$SCRIPTS"        # Split comma-separated list
          TEST_FOLDER="tests/$TEST_TYPE"                    # Path to test folder
          if [ ! -d "$TEST_FOLDER" ] || [ -z "$(ls -A $TEST_FOLDER)" ]; then
            echo "Error: Test folder $TEST_FOLDER missing or empty!"
            exit 1
          fi
          # Validate each script and its data folder
          for script in "${SCRIPT_ARR[@]}"; do
            JMX_PATH="$TEST_FOLDER/$script.jmx"             # Path to JMX file
            DATA_FOLDER="$TEST_FOLDER/data/$script"        # Path to data folder
            if [ ! -f "$JMX_PATH" ]; then
              echo "Error: JMX file $JMX_PATH does not exist!"
              exit 1
            fi
            if [ ! -d "$DATA_FOLDER" ] || [ -z "$(ls -A $DATA_FOLDER)" ]; then
              echo "Warning: Data folder $DATA_FOLDER missing or empty!"
            fi
          done

      # Step: Install JMeter
      - name: Install JMeter
        run: |
          JMETER_VERSION=5.6.3  # Version to install
          curl -L https://downloads.apache.org/jmeter/binaries/apache-jmeter-$JMETER_VERSION.tgz -o jmeter.tgz  # Download
          tar -xzf jmeter.tgz  # Extract
          mv apache-jmeter-$JMETER_VERSION $HOME/jmeter  # Move to home
          echo "$HOME/jmeter/bin" >> $GITHUB_PATH  # Add to PATH

      # Step: Install JMeter plugins
      - name: Install JMeter Plugins
        run: |
          mkdir -p $HOME/jmeter/lib/ext  # Plugin folder
          # Dummy Sampler plugin
          curl -L -o /tmp/jpgc-dummy.zip https://jmeter-plugins.org/files/packages/jpgc-dummy-0.4.zip
          unzip -o /tmp/jpgc-dummy.zip -d /tmp/dummy
          find /tmp/dummy -name "*.jar" -exec cp {} $HOME/jmeter/lib/ext/ \;
          # Ultimate Thread Group plugin
          curl -L -o /tmp/jpgc-ultimate.zip https://jmeter-plugins.org/files/packages/jpgc-casutg-3.1.1.zip
          unzip -o /tmp/jpgc-ultimate.zip -d /tmp/ultimate
          find /tmp/ultimate -name "*.jar" -exec cp {} $HOME/jmeter/lib/ext/ \;

      # Step: Prepare results folder for this instance
      - name: Prepare results folder
        run: mkdir -p results/${{ needs.prepare.outputs.RUN_ID }}

      # Step: Run JMeter scripts per instance
      - name: Run JMeter scripts
        run: |
          TEST_TYPE="${{ github.event.inputs.test_type }}"
          ENV="${{ github.event.inputs.environment }}"
          SCRIPTS="${{ github.event.inputs.scripts }}"
          RUN_ID=${{ needs.prepare.outputs.RUN_ID }}
          INSTANCE=${{ matrix.instance }}
          IFS=',' read -ra SCRIPT_ARR <<< "$SCRIPTS"
          for script in "${SCRIPT_ARR[@]}"; do
            echo "Running JMeter script: $script.jmx (instance $INSTANCE)"
            TEST_FOLDER="tests/$TEST_TYPE"
            RESULTS_FOLDER="results/$RUN_ID"
            # Run JMeter non-GUI mode and save JTL and log
            jmeter -n -t "$TEST_FOLDER/$script.jmx" \
                   -l "$RESULTS_FOLDER/$script-instance$INSTANCE.jtl" \
                   -j "$RESULTS_FOLDER/$script-instance$INSTANCE.log" \
                   -q "env/$ENV.properties"
            # Generate HTML report (skip if failed)
            jmeter -g "$RESULTS_FOLDER/$script-instance$INSTANCE.jtl" \
                   -o "$RESULTS_FOLDER/$script-instance$INSTANCE-report" || echo "HTML report skipped"
          done

      # Step: Upload individual instance artifacts
      - name: Upload JMeter results
        if: always()  # Upload even if job fails
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-results-${{ needs.prepare.outputs.RUN_ID }}-instance${{ matrix.instance }}
          path: results/${{ needs.prepare.outputs.RUN_ID }}/
          retention-days: ${{ github.event.inputs.retention_days }}

# ==============================
# Optional: Aggregate results into merged JTL and HTML report
# ==============================
  aggregate-results:
    name: Aggregate JMeter Results
    if: ${{ github.event.inputs.action == 'run-tests' && github.event.inputs.aggregate == 'Y' }}
    needs: run-tests
    runs-on: ubuntu-latest

    steps:
      # Checkout repo for aggregation
      - uses: actions/checkout@v4

      # Setup Java for aggregation
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      # Install JMeter on aggregation runner
      - name: Install JMeter
        run: |
          JMETER_VERSION=5.6.3
          curl -L https://downloads.apache.org/jmeter/binaries/apache-jmeter-$JMETER_VERSION.tgz -o jmeter.tgz
          tar -xzf jmeter.tgz
          mv apache-jmeter-$JMETER_VERSION $HOME/jmeter
          echo "$HOME/jmeter/bin" >> $GITHUB_PATH

      # Download all matrix artifacts
      - name: Download matrix artifacts
        uses: actions/download-artifact@v4
        with:
          path: merged-results

      # Merge JTL files into one
      - name: Merge JTL files
        run: |
          mkdir -p final-results  # Folder for merged results
          echo "Merging JTL files from matrix runs..."
          first_file=$(find merged-results -name "*.jtl" | head -n 1)  # Get first file
          if [ -z "$first_file" ]; then
            echo "❌ No JTL files found in artifacts!"
            exit 1
          fi
          head -n 1 "$first_file" > final-results/merged.jtl  # Copy header
          find merged-results -name "*.jtl" | while read file; do
            tail -n +2 "$file" >> final-results/merged.jtl  # Append without header
          done
          echo "✅ Merged JTL created at final-results/merged.jtl"

      # Generate merged HTML report
      - name: Generate merged HTML report
        run: |
          jmeter -g final-results/merged.jtl -o final-results/merged-report || echo "⚠️ Report generation skipped"

      # Upload merged artifacts
      - name: Upload merged results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-merged-results-${{ needs.prepare.outputs.RUN_ID }}
          path: final-results/
          retention-days: ${{ github.event.inputs.retention_days }}
